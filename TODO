Steps:
1. twitter:
   * login integration
   * collector manager
2. image processing:
   * make osaic.py a library: passing file or db-obj handles
     osaic.mosaicify(target_image=dbobj, source_images=[source_image db_objs (or SourcePosition objs)], class=MosaicRender, strategy=Strategy), zoom=1,
            Strategy(targetX,targetY,num_sources)
   * django update/creation command (using files)
     * cron job with a 'ready' flag might be enough here



Jobs/Threads:
 * Twitter API updates (streaming and/or REST)
 * downloading images
 * rendering mosaic + jsondata

Per project:
 Input:
  * hashtag/search
    * default filter:safe
  * mosaic target image
  * how many images to collect at minimum
  * target region (for later) (US/State/City)

 Processing/State
  * tweet list
  * earliest tweet/latest tweet (for max_id or since)
  * images
    * image count
  * last render
    * last render image count


Features (for future):
 * geo search/categorization
 * default target image is image of country or state?
 * !! mosaic animated gifs (x frames)
 * !! mosaic with geo position e.g. if a state or state abbrev is in tweet, then 
      locate them on US map
 

Basic Interface:
 * show mosaic
 * overlay translucent version of image
 * on click, show tweet + user
 * maybe show stream of tweeters


Mosaic code:
https://bitbucket.org/iamFIREcracker/osaic/src/02e6a8cc0dcd2415a015090d628258840604b765/osaic.py?fileviewer=file-view-default
https://github.com/cinemast/OpenMosaic
https://github.com/ideamonk/PyMos/blob/master/pymos/core.py


http://www.sfgiantsflytogether.com/
https://dev.twitter.com/rest/tools/console
https://dev.twitter.com/rest/public
https://dev.twitter.com/oauth/application-only
  *can't connect to streaming endpoints

twitter python libraries (that having streaming)
seems to be the big one:
  https://github.com/tweepy/tweepy
  http://tweepy.readthedocs.org/en/v3.5.0/getting_started.html
another one:

Similar commercial tools:
http://hyperactivate.com/hashtagart-mosaic/
http://picturemosaics.com/online/

Good example:
http://www.sfgiantsflytogether.com/

Nik:
For the MVP, I think the tool should be able to collect and download public profile photos from Twitter users who use a specific hashtag, and then upload them into a free mosaic creation tool like Mosaicly.

Eventually, the tool would be able to pull from Twitter, Facebook, Instagram, and Tumblr, as well as take direct submissions of photos, into our own mosaic creating back-end system in real time.

Then later down the line, the mosaic would be interactive (i.e. People could zoom in and search for themselves), embedable, have performance analytics and other bells and whistles that are yet to be determined.

Ultimately, it would be incredible to have a turn-key solution similar to Hyperactivate's product.

Not sure where this fits in the development, but it would ask be great to be able to integrate with something like CleanSpeak, a service which automatically flags and rejects content that has hate speech, porn, etc. Not exactly sure how it works.


Image processing nerd-sniping
=============================

* see the pixel_hash and pixel_cmp methods here:
  https://github.com/python-pillow/Pillow/blob/master/libImaging/Quant.c#L68
  that PILlow uses to quantize image (with k-means)
  seems like the best way to 'reduce' the colors if we don't want just one


How to best-match tiles to locations?
-------------------------------------

Strategy Goals:
* optiimizing color choice: best image (use lower N and then pick/optimize based on color matches)
* uniqueness: every tile should be a different image
* guarantee participation: every one should be in at least one iteration?
  (interface to 'find oneself'; user-->image)

Twitter strategy:
1. get tweets.  store all tweets, even if users are duplicated
2. each source image AND target tile should have average hue AND average luminance
3. group target tiles (possibly across many images) into buckets of:
   X colors, with anything of too-high or too-low luminance into one bucket
   (note: save this distribution for analysis, and help to the moderators of what kind of
          source images they want to add/provide)
4. within buckets, move things in/out based on luminance, and then sort within and match


Making the participation problem easier:
* multiple images (with different color schemes) [possibly ]
* images with 'color categories' -- i.e. the colors don't matter as much as the distinctions
  -- and then we group color-palletes (basically multiple images but 'one source', along with 'x' pallettes)

